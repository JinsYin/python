{"./":{"url":"./","title":"简介","keywords":"","body":"Python 知识库 LICENSE Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/installation.html":{"url":"basics/installation.html","title":"安装","keywords":"","body":"安装 Python 以 Ubuntu 14.04 为例。 安装 Python 使用内置源安装 python2 $ # 通常，默认安装了 python 2.7 $ python --version Python 2.7.6 $ # 安装 $ apt-get install python 使用内置源安装 python3 $ # 通常，默认安装了 python 3.4 $ python3 --version Python 3.4.3 $ # 安装 $ apt-get install python3 编译安装 # 会自动安装 python 和 pip $ wget https://www.python.org/ftp/python/3.5.3/Python-3.5.3.tgz $ tar xzf Python-3.5.3.tgz $ cd Python-3.5.3 $ ./configure $ make install $ # 安装路径 $ ll /usr/local/bin/python* $ ll /usr/local/bin/pip* $ # 重新建立软连接 $ rm /usr/bin/python && ln -s /usr/local/bin/python3.5 /usr/bin/python $ rm /usr/bin/pip3 && ln -s /usr/local/bin/pip3 /usr/bin/pip3 安装 pip 使用内置源 python-pip $ # 通常，默认安装了 python-pip（python2.7） $ pip --version pip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7) $ # 安装 $ apt-get install python-pip $ # 升级 $ pip install --upgrade pip 使用内置源 python3-pip $ # 安装 $ apt-get install python3-pip $ pip --version pip 9.0.1 from /usr/local/lib/python3.4/site-packages (python 3.4) $ # 升级 $ pip3 install --upgrade pip Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"quickstart.html":{"url":"quickstart.html","title":"入门","keywords":"","body":"Python 快速入门 命令行交互 root@node:~$ python Python 3.5.3 (default, Aug 22 2017, 20:36:50) [GCC 4.8.4] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> >>> 100 + 200 300 >>> >>> exit() # CTRL + D Hello Wold 编写 hello_world.py #!/usr/bin/env python3 import sys print(\"Hello, World\") print(\"Python Version: %s\" % sys.version_info[0]) 设置运行时环境时，通常不直接指定 python 的执行路径，因为各个系统的路径可能不同 执行 Python 代码 # 方式一：运行时环境由当前解释器决定，即 python2 $ python2 hello_world.py Hello, World Python Version: 2 # 方式二：运行时环境由 \"#!/usr/bin/env python3\" 决定 $ chmod +x hello_world.py && ./hello_world.py Hello, World Python Version: 3 Encoding Python 3 源码文件默认使用 UTF-8 编码，但有些编辑器可能默认不是 UTF-8 编码。有三种方式可以修改编码： # coding: utf-8 # coding=utf-8 # -*- coding: utf-8 -*- Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"datatype/":{"url":"datatype/","title":"数据类型","keywords":"","body":"Python 类型 基础类型 字符串（str） 布尔型（bool） 数字类型 整型（int） 浮点型（float） 复数型 字节型（bytes） string1 = \"abc\" string2 = \"123\" bool_t = True int_num = 10 float_num = 1.1 import pickle dic = {\"x\": 1, \"y\": 2} dic_bytes = pickle.dump(dic) # b'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x00xq\\x01K\\x01X\\x01\\x00\\x00\\x00yq\\x02K\\x02u.' print(dic_bytes, type(dic_bytes)) 类型诊断 builtins 模块内置的 type() 方法可以诊断对象的类型。 x = True print(type(x)) # 类型转换 str -> int/float int_string = \"123\" float_string = \"12.3\" int_num = int(int_string) float_num = float(float_string) print(type(int_num)) print(type(float_num)) int/float -> str print(str(10)) print(str(1.1)) str & bytes http://blog.csdn.net/yatere/article/details/6606316 字典 dic1 = {'x': 1, 'y': 2} dic2 = dict('x'=1, 'y'=2) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"datatype/list.html":{"url":"datatype/list.html","title":"list","keywords":"","body":"Python list 数据类型 实现原理 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"datatype/set.html":{"url":"datatype/set.html","title":"set","keywords":"","body":"Python set 数据类型 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"oprators/":{"url":"oprators/","title":"运算符","keywords":"","body":"Python 运算符 Operator Expression Internally Addition p1 + p2 p1.add(p2) Subtraction p1 - p2 p1.sub(p2) 参考 Python Operator Overloading Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/closures.html":{"url":"basics/closures.html","title":"闭包","keywords":"","body":"Python 闭包 嵌套函数 def print_msg(number): def printer(): \"Here we are using the nonlocal keyword\" nonlocal number number=3 print(number) printer() print(number) \"\"\" 有 nonlocal: 3 3 无 nonlocal: 3 9 \"\"\" print_msg(9) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/comment.html":{"url":"basics/comment.html","title":"注释","keywords":"","body":"Python 注释 规范 class People: def __init__(self, name, age): \"\"\"构造方法 args: name:[str] 用户名 age:[int] 年龄 \"\"\" this.name = name this.age = age def test(x, y): \"\"\"求和 args: x:[int] y:[int] returns: z:[int] \"\"\" z = x + y return z 参考 Lib/code Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/function.html":{"url":"basics/function.html","title":"函数","keywords":"","body":"Python 函数 函数参数 位置参数（Positional Arguments） def func(x, y): \"\"\"参数必须、无默认值\"\"\" pass func(1, 2) func(x=1, y=2) func(y=2, x=1) 关键字参数（Keyword Arguments） def func(name, age=None, score=60): \"\"\"参数可选且有默认值\"\"\" if age is not None: print(name) print(age) print(score) func(\"John\") func(\"John\", 18) func(\"John\", 18, 100) func(\"John\", score=18) func(\"John\", score=100, age=18) 可变参数列表（Arbitrary Argument List） def func(first, *args): \"\"\"任意参数列表（arbitrary argument list）\"\"\" pass func(\"first\") func(\"first\", 1) func(\"first\", 1, [\"x\", \"y\"]) 可变关键字参数字典（Arbitrary Keyword Argument Dictionary） def func(first, **kwargs): if kwargs[\"name\"]: pass func(\"first\") func(\"first\", name=\"John\") func(\"first\", name=\"John\", age=18) 参考 Function arguments Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/conditions.html":{"url":"basics/conditions.html","title":"条件表达式","keywords":"","body":"条件表达式 运算符 布尔运算符（\"and\" / \"or\"） if name = \"John\" and age = 18: pass if name = \"John\" or name = \"Tim\": pass \"in\" 运算符 \"in\" 运算符判断某个对象是否 真假值表 真 假 True False 非空字符串 '' 非零数字 0 0.0 ... 0.00000 非空容器 [] {} () set() ... None 参考 这是针对 Python 2 的：https://docs.python.org/release/2.5.2/lib/truth.html Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/error.html":{"url":"basics/error.html","title":"错误（Error）","keywords":"","body":"Error finally 始终被执行 # 始终返回 3 try: return 1 except: return 2 finally: return 3 捕获所有异常 try: do_something() except: print(\"Caught all exceptions\") try: f = open('myfile.txt') s = f.readline() i = int(s.strip()) except IOError as (errno, strerror): print \"I/O error({0}): {1}\".format(errno, strerror) except ValueError: print \"Could not convert data to an integer.\" except: print \"Unexpected error:\", sys.exc_info()[0] raise 没有捕获到的异常自动被抛出 解释器可以捕获的异常 NameError >>> str(x) Traceback (most recent call last): File \"\", line 1, in NameError: name 'f' is not defined Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/exception.html":{"url":"basics/exception.html","title":"异常（Exception）","keywords":"","body":"异常（Exception） ImportError try: import readline except ImportError: pass Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/module.html":{"url":"basics/module.html","title":"模块","keywords":"","body":"Python 模块 Python 3 的入口模块是 builtins，Python 2 对应的是 __builtin__ 模块。它包含常见的 print()、abs() 方法，+、- 等等操作符 内置模块 查看当前解释器默认导入了哪些模块： >>> impoort sys >>> sys.modules.keys() dict_keys(['builtins', 'sys', '_frozen_importlib', '_imp', '_warnings', '_thread', '_weakref', '_frozen_importlib_external', '_io', 'marshal', 'posix', 'zipimport', 'encodings', 'codecs', '_codecs', 'encodings.aliases', 'encodings.utf_8', '_signal', '__main__', 'encodings.latin_1', 'io', 'abc', '_weakrefset', 'site', 'os', 'errno', 'stat', '_stat', 'posixpath', 'genericpath', 'os.path', '_collections_abc', '_sitebuiltins', 'sysconfig', '_sysconfigdata_m_linux_x86_64-linux-gnu', '_bootlocale', '_locale', 'types', 'functools', '_functools', 'collections', 'operator', '_operator', 'keyword', 'heapq', '_heapq', 'itertools', 'reprlib', '_collections', 'weakref', 'collections.abc', 'importlib', 'importlib._bootstrap', 'importlib._bootstrap_external', 'warnings', 'importlib.util', 'importlib.abc', 'importlib.machinery', 'contextlib', 'mpl_toolkits', 'google', 'sphinxcontrib', 'readline', 'atexit', 'rlcompleter', 're', 'enum', 'sre_compile', '_sre', 'sre_parse', 'sre_constants', 'copyreg']) >>> import builtins >>> builtins.print('123') Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/package.html":{"url":"basics/package.html","title":"包和模块","keywords":"","body":"包和模块 isort - import 排序 安装 pip install isort 示例 example.py from my_lib import Object print(\"Hey\") import os from my_lib import Object3 from my_lib import Object2 import sys from third_party import lib15, lib1, lib2, lib3, lib4, lib5, lib6, lib7, lib8, lib9, lib10, lib11, lib12, lib13, lib14 import sys from __future__ import absolute_import from third_party import lib3 print(\"yo\") # 排序并修改文件 $ isort example.py # 打印排序前后的区别，但不修改文件 $ isort --diff example.py # 递归当前目录下的所有文件 $ isort -rc . 参考 Modules and Packages Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/serialization.html":{"url":"basics/serialization.html","title":"序列化","keywords":"","body":"序列化 json 模块：序列化为 json 字符串 pickle 模块：序列化为二进制数据 shelve 模块： json 模块 序列化为字符串 import json dic = {\"x\": 1, \"y\": 2} dic_str = json.dumps(dic) # 序列化 dic_origin = json.loads(dic_str) # 反序列化 print(dic_str, type(dic_str)) # {\"x\": 1, \"y\": 2} print(dic_origin, type(dic_origin)) # {'x': 1, 'y': 2} 存储为 json 文件 import json dic = {\"x\": 1, \"y\": 2} # 序列化 with open('dic.json', 'w', encoding='utf-8') as f: json.dump(dic, f) # 反序列化 with open('dic.json', 'r', encoding='utf-8') as f: dic = json.load(f) print(dic, type(dic)) # {'x': 1, 'y': 2} 存储到自定义对象 import json me pickle 模块 序列化到变量 import pickle dic = {\"x\": 1, \"y\": 2} dic_bytes = pickle.dumps(dic) # 序列化 dic_origin = pickle.loads(dic_bytes) # 反序列化 print(dic_bytes, type(dic_bytes)) # b'\\x80\\x03}q\\x00(X\\x01\\x00\\x00\\x00xq\\x01K\\x01X\\x01\\x00\\x00\\x00yq\\x02K\\x02u.' print(dic_origin, type(dic_origin)) # {'x': 1, 'y': 2} 序列化到文件 import pickle # 序列化 with open('dic.pk', 'wb') as f: dic = {\"x\": 1, \"y\": 2} pickle.dump(dic, f) f.close() # 反序列化 with open('dic.pk', 'rb') as f: dic = pickle.load(f) print(dic, type(dic)) f.close() Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/syntactic-sugar.html":{"url":"basics/syntactic-sugar.html","title":"语法糖","keywords":"","body":"Python 语法糖 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/generator.html":{"url":"basics/generator.html","title":"生成器","keywords":"","body":"Generator 生成器 # 生成器表达式（generator expression） (i for i in items) # 生成器函数 def generator(): yield 1 yield \"a\" yield [1, 3, 5] print(\"------\") yield {\"name\": \"John\", \"age\": 18} \"\"\" 1 a [1, 3, 5] ------ {'name': 'John', 'age': 18} \"\"\" for x in generator(): print(x) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"basics/introspection.html":{"url":"basics/introspection.html","title":"自省","keywords":"","body":"Code Introspection help() dir() hasattr() id() type() repr() callable() issubclass() isinstance() __doc__ __name__ Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"io/":{"url":"io/","title":"I/O","keywords":"","body":"Python I/O with/as with open('ceph.conf', 'wb') as f: pass Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/conda/REAMDE.html":{"url":"env/conda/REAMDE.html","title":"Conda","keywords":"","body":"Conda Anaconda 的核心是 Conda，同时 Conda 也是一个包管理器。 目录 Anaconda Miniconda Conda 常用命令 Conda 虚拟环境 Conda 与 PIP 参考 GitHub - conda/conda Document - conda Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/conda/anaconda.html":{"url":"env/conda/anaconda.html","title":"Anaconda","keywords":"","body":"Anaconda 安装 建议安装最新版本，且不要使用 root 用户来安装。 # 下载 $ anaconda_version=5.1.0 $ wget -P ~/Downloads/ https://repo.continuum.io/archive/Anaconda3-${anaconda_version}-Linux-x86_64.sh # 校验，校验地址：https://docs.anaconda.com/anaconda/install/hashes/Anaconda3-${anaconda_version}-Linux-x86_64.sh-hash $ md5sum ~/Downloads/Anaconda3-${anaconda_version}-Linux-x86_64.sh 966406059cf7ed89cc82eb475ba506e5 /home/yin/Downloads/Anaconda3-5.1.0-Linux-x86_64.sh # 安装 $ bash ~/Downloads/Anaconda3-${anaconda_version}-Linux-x86_64.sh 安装过程会提示是否添加 Anaconda 的执行环境，如果安装完成后无法执行 anaconda 命令，可以进行如下操作： $ echo 'export PATH=\"~/anaconda3/bin:$PATH\"' >> ~/.bashrc # $PATH 的顺序一定要在 anaconda 之后 $ source ~/.bashrc # 立即生效 # 查看版本 $ anaconda --version && conda --version anaconda Command line client (version 1.6.9) conda 4.4.10 检查 Anaconda 除了会安装一些用于数据分析的 Python 依赖包（路径：~/anaconda3/lib/python3.6/site-packages）外，还会安装一些二进制程序（路径：~/anaconda3/bin），如：python、pip、jupyter、anaconda-navigator 等等。 $ which python /home/yin/anaconda3/bin/python $ which pip /home/yin/anaconda3/bin/pip $ pip --version pip 9.0.1 from /home/yin/anaconda3/lib/python3.6/site-packages (python 3.6) 卸载 # 该模块用于在卸载 Anaconda 时删除配置文件，最新的 Anaconda 已默认安装该模块 $ conda install anaconda-clean # 删除配置文件 ~/.conda 并自动备份 $ anaconda-clean # 删除 Anaconda 目录 $ rm -rf ~/.anaconda3 # 最后移除 .bashrc 中为 Anaconda 添加的 PATH $ vi ~/.bashrc 升级 升级 anaconda 包可以获取最新的软件包。下面以 base 虚拟环境为例： # 先升级 conda 工具 $ conda update conda # 升级完 conda 后，再更新 anaconda 软件包 $ conda update anaconda 参考 How To Install the Anaconda Python Distribution on Ubuntu 16.04 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/conda/commands.html":{"url":"env/conda/commands.html","title":"Conda 常用命令","keywords":"","body":"Conda 常用命令 # 查看安装了哪些软件包及其版本 $ conda list # 查看某个虚拟环境已安装的软件包 $ conda list -n python2.7 # 查看已安装的软件包的版本信息，或者检查软件包是否被安装 $ conda list pip Name Version Build Channel pip 9.0.1 py36h6c6f9ce_4 # 查询所有可安装的软件包，以及可安装的版本 $ conda search # 查询某个软件包可用的版本 $ conda search python $ conda search \"^python$\" # 安装最新版本的软件包 $ conda install numpydoc # 安装指定版本的软件包 $ conda install numpydoc=0.6.0 # 更新某个软件包 $ conda update python # 更新所有软件包 $ conda update # 删除软件包 $ conda remove 注意事项 切勿使用 pip 升级或卸载 conda 安装的软件包；pip 的升级和卸载操作仅限于 pip install 命令安装的软件包。 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/conda/conda-vs-pip.html":{"url":"env/conda/conda-vs-pip.html","title":"Conda 与 PIP","keywords":"","body":"Conda 与 PIP PIP 是依附于 Python 环境而存在的，每个 Python 环境都对应一个 PIP 工具，所以是先有 Python 而后有 PIP，因此 PIP 无法管理 Python 版本。 Conda 创建 Python 虚拟环境后（Python 自带 PIP），可以使用 pip 或 conda 两种方式来安装 Python 包： 如果使用 pip base 环境安装的包位于 ${ANACONDA_HOME}/lib//site-packages/ 目录 其他虚拟环境安装的包位于 ${ANACONDA_HOME}/envs//lib//site-packages/ 目录 如果使用 conda 所有安装的包均位于 ${ANACONDA_HOME}/pkgs/ 目录，每个包可能存在多个版本，每个虚拟环境引用相应版本的包。 当使用 conda 和 pip 安装同一包时， Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/conda/miniconda.html":{"url":"env/conda/miniconda.html","title":"Miniconda","keywords":"","body":"Miniconda 安装 建议安装最新版本，且不要使用 root 用户来安装。 # 下载 $ wget -P ~/Downloads/ https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.sh # 校验，校验地址：https://repo.continuum.io/miniconda/ $ md5sum ~/Downloads/Miniconda3-latest-Linux-x86_64.sh bec6203dbb2f53011e974e9bf4d46e93 /home/yin/Downloads/Miniconda3-latest-Linux-x86_64.sh # 安装 $ bash ~/Downloads/Miniconda3-latest-Linux-x86_64.sh MacOS: wget https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-x86_64.sh -O ~/miniconda.sh bash ~/miniconda.sh -b -p $HOME/miniconda # zsh $ echo 'alias miniconda=\"cd $HOME/miniconda\"' >> ~/.zshrc $ echo 'export PATH=\"$PATH:$HOME/miniconda/bin\"' >> ~/.zshrc 其他 Miniconda 默认的虚拟环境为 root。如果希望把 Miniconda 转变为 Anaconda，只需要在相应的环境安装 anaconda 包即可。 # 虚拟环境 $ conda info --env root * /usr/local # 修改 root 环境下 python 的版本 $ conda install python=3.5 # 安装 anaconda 包 $ conda install anaconda # 升级 conda $ conda update conda Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/conda/virtualenv.html":{"url":"env/conda/virtualenv.html","title":"Conda 虚拟环境","keywords":"","body":"Conda 虚拟环境 conda 默认的虚拟环境为 bash，该环境的路径为：~/anaconda3，其他虚拟环境的路径为 ~/anaconda3/envs/。 # 查看所有虚拟环境（* 表示当前所在的环境） $ conda env list # or: conda info --env base * /home/yin/anaconda3 # 创建虚拟环境（该环境包含 2.7 中最新版本的 python 和最新版本的 numpy） $ conda create --name python2.7 python=2.7 numpy 另外，我当前安装的 Anaconda 使用的 Python 版本为 3.6，如果希望默认的 base 环境使用 Python 3.5，可以直接在默认环境下安装想要的 Python 版本： # base 环境 $ conda install python=3.5 切换虚拟环境（命令行） 进入 python2.7 环境： # Linux & Mac $ source activate python2.7 # Windows $ activate python2.7 回到默认的 base 环境： # Linux & Mac（Linux 下执行 'source ~/.bashrc' 也会退回到 base 虚拟环境） $ source deactivate # or: source deactivate python2.7 # Windows $ deactivate 上面的命令太难记了，试图简化一下（Linux）： $ vi ~/.bashrc alias condaenv='source activate' alias condaexit='source deactivate' # 立即生效 $ source ~/.bashrc # 进入虚拟环境 $ condaenv python2.7 # 退出虚拟环境 $ condaexit 切换虚拟环境（PyCharm IDE） File -> Settings -> Project -> Project Interpreter 删除虚拟环境 $ conda env remove --name python2.7 # 还可以通过删除该环境下所有的包来实现 $ conda remove --name python2.7 --all 完美应用 这种方式不仅会安装指定版本的 Python，还会基于指定的 Python 版本来安装 Anaconda 中所有的包。 % conda create -n python2.7 python=2.7 anaconda % conda create -n python3.5 python=3.5 anaconda Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/virtenv/":{"url":"env/virtenv/","title":"virtenv","keywords":"","body":"Python 虚拟环境 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/virtenv/pyenv.html":{"url":"env/virtenv/pyenv.html","title":"pyenv","keywords":"","body":"pyenv Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"env/virtenv/venv.html":{"url":"env/virtenv/venv.html","title":"venv","keywords":"","body":"vend Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/":{"url":"libs/cpython/","title":"标准库","keywords":"","body":"CPython 标准库 标准库 描述 builtins 内置函数；默认加载 functools multiprocessing 多进程 threading 多线程 参考 cpython Lib Python 标准库 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/builtins/":{"url":"libs/cpython/builtins/","title":"builtins","keywords":"","body":"Python builtins 模块 内置对象 内置函数 内置常量 内置类型 内置异常 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/builtins/constants/":{"url":"libs/cpython/builtins/constants/","title":"constants","keywords":"","body":"内置常量 常量 描述 False True None NotImplemented Ellipsis debug 由 site 模块添加的常量 site 模块（在启动期间自动导入，除非给出 -S 命令行选项）将几个常量添加到内置命名空间。 它们对交互式解释器 shell 很有用，并且不应在程序中使用。 site 模块 描述 quit(code=None) exit(code=None) copyright credits license 参考 内置常量 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/builtins/exceptions/":{"url":"libs/cpython/builtins/exceptions/","title":"exceptions","keywords":"","body":"内置异常 BaseException +-- SystemExit +-- KeyboardInterrupt +-- GeneratorExit +-- Exception +-- StopIteration +-- StopAsyncIteration +-- ArithmeticError | +-- FloatingPointError | +-- OverflowError | +-- ZeroDivisionError +-- AssertionError +-- AttributeError +-- BufferError +-- EOFError +-- ImportError | +-- ModuleNotFoundError +-- LookupError | +-- IndexError | +-- KeyError +-- MemoryError +-- NameError | +-- UnboundLocalError +-- OSError | +-- BlockingIOError | +-- ChildProcessError | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError | +-- FileNotFoundError | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError +-- ReferenceError +-- RuntimeError | +-- NotImplementedError | +-- RecursionError +-- SyntaxError | +-- IndentationError | +-- TabError +-- SystemError +-- TypeError +-- ValueError | +-- UnicodeError | +-- UnicodeDecodeError | +-- UnicodeEncodeError | +-- UnicodeTranslateError +-- Warning +-- DeprecationWarning +-- PendingDeprecationWarning +-- RuntimeWarning +-- SyntaxWarning +-- UserWarning +-- FutureWarning +-- ImportWarning +-- UnicodeWarning +-- BytesWarning +-- ResourceWarning 参考 Built-in Exceptions Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/builtins/functions/":{"url":"libs/cpython/builtins/functions/","title":"functions","keywords":"","body":"内置函数 I/O 范例 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/builtins/stdtypes/":{"url":"libs/cpython/builtins/stdtypes/","title":"stdtypes","keywords":"","body":"内置类型 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/logging/":{"url":"libs/cpython/logging/","title":"logging","keywords":"","body":"logging 模块 日志用途 程序调试 掌握程序运行情况 程序运行故障分析和问题定位 日志事件 一条日志对应一个事件的发生，一个事件通常包含以下几个内容： 事件发生时间 事件发生位置 -- 回溯 & 日志记录位置 事件严重程度 -- 日志级别 事件内容 日志级别（Level） Level ID / Level Value Level Name 描述 10 DEBUG 最详细的日志信息，通常用于问题诊断 20 INFO 详细程度次于 DEBUG，通常只记录关键信息，以确认是否按照预期在进行工作 30 WARNING 当某些不期望的事情发生时记录的信息（如，磁盘可用空间较低），但是此时应用程序还是正常运行的 40 ERROR 由于一个更严重的问题导致某些功能不能正常运行时记录的信息 50 CRITICAL 当发生严重错误，导致应用程序不能继续运行时记录的信息 数值越大级别越高（即 DEBUG ），记录的日志信息越少 指定日志级别后，程序会记录所有 大于或等于 该日志级别的日志信息，而不是只记录当前级别的日志信息 logging 模块提供的日志记录函数所使用的日志器默认设置的日志级别为 WARNING，所以默认情况下 DEBUG 和 INFO 都不会被记录 开发环境建议： DEBUG、 INFO 生产环境建议： WARNING、 ERROR、 CRITICAL 模块函数 日志配置函数 描述 logging.basicConfig(**kwargs) 对 rootLogger 进行一次性配置，常指定 “日志级别”、“日志格式”、“日志输出位置” 等信息 关键字参数: filename : 指定日志输出文件的文件名；设置后日志信息将不再输出到默认的 sys.stderr filemode : 指定日志输出文件的打开模式；默认是 a；指定 filename 后才有效 format : 指定日志格式 -- 按格式字段排列组合形成的字符串 datefmt : 指定日期/时间格式；format 选项包含 %(asctime)s 字段时才有效 level : 指定日志级别 stream : 指定日志输出目标流，如：sys.stdout、sys.stderr 或网络流；stream 和 filename 两个选项不能同时指定 style : Py3.2 新增。指定 format 格式字符串的风格，可取值为 %、{ 或 $，默认为 % handlers : Py3.3 新增。 日志记录函数 描述 logging.debug(msg, args, *kwargs) 创建一条严重级别为 DEBUG 的日志记录 logging.info(msg, args, *kwargs) 创建一条严重级别为 INFO 的日志记录 logging.warning(msg, args, *kwargs) 创建一条严重级别为 WARNING 的日志记录 logging.error(msg, args, *kwargs) 创建一条严重级别为 ERROR 的日志记录 logging.exception(msg, args, exc_info=True, *kwargs) 创建一条严重级别为 ERROR 的日志记录，并且打印异常堆栈信息 logging.critical(msg, args, *kwargs) 创建一条严重级别为 CRITICAL 的日志记录 logging.log(level, args, *kwargs) 创建一条严重级别为 level 的日志记录（有自定义 level 时更常用） 关键字参数: exc_info : 是否增加异常堆栈信息（仅出现异常时才有信息）；取值为布尔值，除 logging_exception() 函数外默认值均为 False stack_info : 是否增加堆栈信息（不论是否异常始终存在信息）；取值为布尔值，默认值均为 False extra : 用于设置 logging.basicConfig(...) 中 format 参数自定义字段的值；取值为字典，如：extra={'ip': '12.34.56.78'} import logging logging.basicConfig(level=logging.DEBUG) def log(): try: 1 / 0 except BaseException as e: print(e) print('-----') logging.debug(e) print('-----') logging.info(e) print('-----') logging.info(e, stack_info=True) print('-----') logging.warning(e) print('-----') logging.error(e) print('-----') logging.exception(e) print('-----') logging.error(e, exc_info=True) print('-----') logging.critical(e) 注：引入的外部模块通常会指定 DEBUG 级别的日志记录，比如 urllib3 四大组件 组件 类名 功能 日志器 Logger 处理器 Handler 过滤器 Filter 格式器 Formatter 日志格式 字段 格式 描述 asctime %(asctime)s 日志事件发生的事件，形如：2019-01-01 12:20:30,456 levelname %(levelname)s 日志级别，如：DEBUG、INFO、ERROR... name %(name)s 日志器名称，默认是 root（因为使用的是 rootLogger） message %(message)s 日志内容 pathname %(pathname)s 调用的日志函数所在源文件的绝对路径 filename %(filename)s pathname 的文件名部分，包含文件后缀 module %(module)s filename 的名称部分，不含文件后缀 lineno %(lineno)d 调用日志函数的源代码所在的行号 funcName %(funcName)s 调用日志函数的函数名 默认日志输出位置：sys.stderr 默认日志格式：logging.BASIC_FORMAT = \"%(levelname)s:%(name)s:%(message)s\" 如需修改日志格式，可以向 logging.basicConfig(**kwargs) 函数传递 format 参数 除此之外，还可以自定义字段（自定义后调用模块函数就必须为其赋值，否则会报 KeyError: '...'）： LOG_FORMAT = \"%(asctime)s - %(levelname)s - %(user)s[%(ip)s] - %(message)s\" DATE_FORMAT = \"%m/%d/%Y %H:%M:%S %p\" logging.basicConfig(format=LOG_FORMAT, datefmt=DATE_FORMAT) logging.warning(\"Some one delete the log file.\", exc_info=True, stack_info=True, extra={'user': 'Tom', 'ip':'47.98.53.222'}) 范例 import time import logging lg_level = logging.INFO lg_filename = 'main.log.%s' % time.strftime(\"%Y%m%d\") lg_datefmt = '%Y-%m-%d %H:%M:%S' lg_fmt = '%(asctime)s.%(msecs)03d - [%(levelname)s] - %(filename)s:%(lineno)d - %(message)s' logging.basicConfig(level=lg_level, filename=lg_filename, format=lg_fmt, datefmt=lg_datefmt) 参考 Python 之日志处理（logging 模块） python 之配置日志的几种方式 Exceptional logging of exceptions in Python Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/email/":{"url":"libs/cpython/email/","title":"email","keywords":"","body":"Email 范例 { \"server\": { \"host\": \"smtp.qq.com\", \"port\": 25, \"sslport\": 465 }, \"sender\": { \"username\": \"123456789@qq.com\", \"authcode\": \"abcedfghijklmn\" }, \"receivers\": [ \"example@163.com\", \"example@gmail.com\" ] } import json import email.mime.text import MIMEText class Mail(): def __init__(self, path): self.cfg = self.__loadcfg(path) self.sender = cfg['sender']['username'] self.receivers = cfg['receivers'] self.authcode = cfg['sender']['authcode'] # 授权码 self.host = cfg['server']['host'] self.sslport = cfg['server']['sslport'] def __loadcfg(self, path): ret = {} try: with open(path, 'r') as f: ret = json.loads(path) f.close() except OSError as e: logging.info('[系统异常] {}'.format(e)) return ret def send(self): pass def sendtext(self, text, subtype='plain'): '''发送文本 ''' try: message = MIMEText(text, subtype, 'utf-8') message['Subject'] = '抢单成功' message['From'] = '{}'.format(sender) message['To'] = '{}'.join(receivers) server = smtplib.SMTP_SSL(self.host, self.sslport) server.login(username, authcode) result = cxt.sendmail(self.sender, self.receivers, message.as_string()) if result == {}: logging.info('[邮件发送成功]') server.quit() except smtplib.SMTPException as e: logging.info('[SMTP异常] {}'.format(e)) def sendimage(self): '''发送图片 ''' pass Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/json/":{"url":"libs/cpython/json/","title":"json","keywords":"","body":"Json json import json print(json.loads('{\"name\": \"John\", \"age\": 18}')) # √ print(json.loads(\"{'name': 'John', 'age': 18}\")) # × JSONDecodeError 范例 python Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/dis/":{"url":"libs/cpython/dis/","title":"dis","keywords":"","body":"dis 模块 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/re/":{"url":"libs/cpython/re/","title":"re","keywords":"","body":"Python re 模块 正则方法 方法 描述 re.match(pattern, string[, flags]) 从首字母开始匹配，如果 string 包含 pattern 子串则返回 Match 对象，否则返回 None；若要完全匹配，pattern 要以 $ 结尾 re.search(pattern, string[, flags]) 若 string 中包含 pattern 子串，则返回 Match 对象，否则返回 None；如果 string 中存在多个 pattern 子串，只返回第一个 re.findall(pattern, string[, flags]) 若 pattern 中没有 group，则以字符串数组形式返回 string 中与 pattern 相匹配的所有子串；若有 group，则返回所有 group 组成的元组（相当于 Match 对象的 groups() 方法）的数组 re.finditer(pattern, string[, flags]) 若 pattern 中没有 group，则以 Match 对象的迭代器形式返回 string 中与 pattern 相匹配的所有子串 Match 对象相关的属性和方法 方法 描述 group()/group(0) 返回 pattern 从母串中匹配到的子串（其实并未涉及 group） group(i) 从 pattern 匹配到的子串中，返回 pattern 中 第 i 个 group（即第 i 个括号） 匹配成功的子串（条件：先是 pattern 匹配成功，然后是 pattern 中必须存在 group） groups() 返回 所有 group（即所有括号） 组成的元组（不包括第 0 个 group；满足的条件同上） string 返回母串 $ python >>> import re >>> >>> p1 = r'(\\d*)([a-zA-Z]*)' >>> p2 = r'(\\d+)' >>> s = '123abc456def' >>> >>> m1 = re.match(p1, s) >>> m1.string # '123abc456def' >>> m1.group() == m.group(0) # True >>> m1.group() # '123abc' >>> m1.group(0) # '123abc' >>> m1.group(1) # '123' >>> m1.group(2) # 'abc' >>> m1.groups() # ('123', 'abc') >>> >>> m2 = re.findall(p1, s) >>> m2 # [('123', 'abc'), ('456', 'def'), ('', '')] --> 存在第三个的原因是用的 * 而不是 + >>> >>> m3 = re.findall(p2, s) >>> m3 # ['123', 'abc'] 参考 Python 中 re 的 match、search、findall、finditer 区别 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/os/":{"url":"libs/cpython/os/","title":"os","keywords":"","body":"Python os 模块 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/sys/":{"url":"libs/cpython/sys/","title":"sys","keywords":"","body":"sys sys.exit(0) # 正常退出 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/signal/":{"url":"libs/cpython/signal/","title":"signal","keywords":"","body":"signal 编号 名称 描述 1 SIGHUP 2 SIGINT 3 SIGQUIT 9 SIGKILL 14 SIGALRM 15 SIGTERM # 参考 Linux 手册页 $ man 7 signal $ kill -l signal.signal() 不能捕捉 SIGKILL 信号，否则会报 \"[Errno 22] Invalid argument\" 示例 \"\"\" 尝试按下 CTRL + C（即发送 Interrupt 信号），看看会发生什么 * KeyboardInterrupt 并未被捕获到 * signal 的优先级应该是最高的，当接收到中断信号是（`sig == 2`），导致执行 `sys.exit(0)`，程序捕获到 SystemExit 异常 \"\"\" import sys, time, signal def test(g): print(\"start\") for i in range(1, 30): g = g + i print(g) time.sleep(3) print(\"end\") def handle_signal(sig, frame): print(\"signal: {}, g: {}\".format(sig, g)) if sig == 2: sys.exit(0) if __name__ == '__main__': g = 100 signal.signal(1, handle_signal) signal.signal(2, handle_signal) try: test(g) except KeyboardInterrupt: print(\"键盘中断\") except Exception as e: print(\"Exception 异常: {}\".format(e)) except SystemExit as exitno: print(\"SystemExit 异常: {}\".format(exitno)) # 这个位置几乎不可能接收得到信号 #signal.signal(1, handle_signal) #signal.signal(2, handle_signal) \"\"\"x.py * 尝试按下 CTRL + C（即发送 Interrupt 信号），看看会发生什么 * Linux 发送信号: kill -15 $(ps -ef | grep \"python x.py\" | head -n 1 | awk '{print $2}') \"\"\" import sys, time, signal def test(g): print(\"start\") for i in range(1, 20): g = g + i print(g) time.sleep(3) signal.signal(1, handle_signal) signal.signal(2, handle_signal) signal.signal(3, handle_signal) signal.signal(15, handle_signal) print(\"end\") def handle_signal(sig, frame): print(\"signal: {}, frame.f_globals: {}, frame.f_locals: {}，g: {}\"\\ .format(sig, frame.f_globals, frame.f_locals, frame.f_locals['g'])) if sig == 15: sys.exit(0) if __name__ == '__main__': g = 100 try: test(g) except KeyboardInterrupt: print(\"键盘中断\") except Exception as e: print(\"Exception: {}\".format(e)) except SystemExit as exitno: print(\"SystemExit: {}\".format(exitno)) # 这个位置几乎不可能接收得到信号 # signal.signal(1, handle_signal) # signal.signal(2, handle_signal) import code, traceback, signal def debug(sig, frame): \"\"\"Interrupt running process, and provide a python prompt for interactive debugging.\"\"\" d={'_frame':frame} # Allow access to frame object. d.update(frame.f_globals) # Unless shadowed by global d.update(frame.f_locals) i = code.InteractiveConsole(d) message = \"Signal received : entering python shell.\\nTraceback:\\n\" message += ''.join(traceback.format_stack(frame)) i.interact(message) def listen(): signal.signal(signal.SIGUSR1, debug) # Register handler Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/traceback/":{"url":"libs/cpython/traceback/","title":"traceback","keywords":"","body":"traceback 模块 函数 函数 描述 format_exc() 返回错误堆栈字符串 print_exc() 打印错误堆栈字符串；还可以接受file参数直接写入到一个文件,如 traceback.print_exc(file=open('tb.txt','w+')) print_stack() 打印调用栈信息（不论异常与否） Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/itertools/":{"url":"libs/cpython/itertools/","title":"itertools","keywords":"","body":"itertools Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/_thread/":{"url":"libs/cpython/_thread/","title":"_thread","keywords":"","body":"_thread - 底层多线程 API Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/threading/":{"url":"libs/cpython/threading/","title":"threading","keywords":"","body":"threading 模块 - 基于线程的并发 模块函数、常量 Thread 类 class threading.Thread(group=None, target=None, name=None, args=(), kwargs={}, *, daemon=None) 必需的关键字参数： group - target - name - args - kwargs - 方法： 类属性和方法 描述 start() run() join(timeout=None) name getName() setName() ident is_alive() daemon isDaemon() setDaemon() Lock 类 class threading.Lock acquire(blocking=True, timeout=-1) release() 递归锁对象 条件对象 信号量对象 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/threading/GIL/":{"url":"libs/cpython/threading/GIL/","title":"GIL","keywords":"","body":"Python GIL 全局解释器锁 参考 深入理解 GIL：如何写出高性能及线程安全的 Python 代码 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/multiprocessing/":{"url":"libs/cpython/multiprocessing/","title":"multiprocessing","keywords":"","body":"multiprocessing 模块 - 基于进程的并发 概述 同时支持本地和远程并发 使用子进程代替线程，有效避免 GIL 带来的影响 允许程序员充分利用机器上的多个核心 支持 Unix 和 Windows Process 类 from multiprocessing import Process 上下文和启动方法 multiprocessing 支持三种启动进程的方法： 方法 描述 支持平台 spawn * 父进程启动一个新的 Python 解释器进程 Unix、 Windows（默认设置） fork Unix（默认设置） forkserver 父进程首先启动一个新的服务器进程 当需要新进程时，父进程连接并请求服务器进程，由服务器进程创建一个新进程 * 服务器子进程是单线程的，因此使用 os.fork() 是安全的 Unix；支持通过 Unix 管道传递文件描述符 使用 multiprocessing.set_start_method() 方法设置启动方法，使用 multiprocessing.get_context() 获取上下文对象。 import multiprocessing as mp def 进程间通信 multiprocessing 支持进程间的两种通信通道： 队列 multiprocessing.Queue 是线程和进程安全的，近似于 queue.Queue 的克隆。 管道 multiprocessing.Pipe() 函数返回一个由管道连接的连接对象，默认情况下是 双工（即能够同时收发）。 ``` 如果两个进程（或线程）同时尝试读取或写入管道的同一端，则管道中的数据可能会损坏 ## 进程间同步 ```python import os,time import multiprocessing as mp def f(l, i): l.acquire() # 获得锁 time.sleep(1) print('pid: {}, num: {}'.format(os.getpid(), i)) l.release() # 释放锁 if __name__ == '__main__': print('pid: {}'.format(os.getpid())) lock = mp.Lock() for num in range(10): mp.Process(target=f, args=(lock, num,)).start() 进程间共享状态 共享内存 服务器进程 范例 python Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/cpython/multiprocessing/processsafe.html":{"url":"libs/cpython/multiprocessing/processsafe.html","title":"进程安全","keywords":"","body":"进程安全 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/":{"url":"libs/3rdparty/","title":"第三方库","keywords":"","body":"Python 第三方库 数据科学库 jupyter numpy pandas matplotlib seaborn scipy statsmodels 爬虫库 requests Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/jupyter/":{"url":"libs/3rdparty/jupyter/","title":"jupyter","keywords":"","body":"Jupyter 组件 Jupyter Notebook Jupyter Notebook 原名 IPython Notebook，它是一个交互式计算环境，可以在其中组合代码执行，如富文本，数学，图表。 Jupyter 与 IPython 相同点 使用同一个 kernel 不同点 快速入门 % jupyter notebook Jupyter 的 Python 版本问题 Jupyter Notebook 中使用的 Python 版本和它启动时所处环境的 Python 版本一致。 验证 Python 版本 # 查看当前环境所使用的 Python 版本 $ python --version Python 3.6.4 :: Anaconda custom (64-bit) # 在 Jupyter Notebook 中执行代码验证 Python 版本 $ jupyter notebook import sys print(sys.version) 改变 Python 版本 如果希望改变 Jupyter Notebook 中 Python 的版本，可以使用 conda 切换虚拟环境并重启 Jupyter Notebook。 # 切换虚拟环境（假设之前已经创建好） $ source activate python3.5 # 需要重启 $ jupyter notebook 参考 https://zhidao.baidu.com/question/1242805645188455019.html Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/jupyter/ipython.html":{"url":"libs/3rdparty/jupyter/ipython.html","title":"IPython","keywords":"","body":"IPython 补全 IPython 提供了 Tab 补全功能： 补全命名空间所存在的对象（变量、函数、关键字、文件路径等） 补全任何对象、模块的属性和方法 $ ipython In [1]: an_apple = 100 In [2]: an_orange = 200 In [3]: an an_apple anaconda3/ an_orange and any() $ ipython In [1]: b = [1, 2,3] In [2]: b. append() count() insert() reverse() clear() extend() pop() sort() copy() index() remove() $ ipython In [1]: import datetime In [2]: datetime. date() MAXYEAR timedelta datetime MINYEAR timezone datetime_CAPI time() tzinfo() IPython 默认会隐藏下划线开头的属性和方法，除非手动键入了一个下划线 自省 变量前后使用问号 ?，可以显示对象的信息 变量前后使用两个问号 ??，可以显示函数的源码 $ ipython In [1]: b = [1, 2, 3] In [2]: def sum(x, y): ...: \"求和\" ...: return x + y In [3]: b? Type: list String form: [1, 2, 3] Length: 3 Docstring: list() -> new empty list list(iterable) -> new list initialized from iterable's items In [4]: sum? Signature: sum(x, y) Docstring: 求和 File: ~/ Type: function In [5]: sum?? Signature: sum(x, y) Source: def sum(x, y): \"求和\" return x + y File: ~/ Type: function Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/matplotlib/":{"url":"libs/3rdparty/matplotlib/","title":"matplotlib","keywords":"","body":"Matplotlib Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/numpy/":{"url":"libs/3rdparty/numpy/","title":"numpy","keywords":"","body":"Numpy Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/numpy/quickstart.html":{"url":"libs/3rdparty/numpy/quickstart.html","title":"Numpy 快速入门","keywords":"","body":"Numpy 快速入门 练习 导入模块并查看其版本 import numpy as np print(np.__version__) #> 1.14.1 创建一个一维数组 np.arange(10) #> array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 创建一个 3 × 3 的所有值为 True 的 numpy 数组 np.full((3, 3), True) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/pandas/":{"url":"libs/3rdparty/pandas/","title":"pandas","keywords":"","body":"Pandas Pandas 是一种列存数据结构分析 API。 安装 # Conda $ conda install pandas # PyPI $ python3 -m pip install --upgrade pandas 基本概念 主要数据结构 DataFrame - 相当于一个关系型数据表格，包含多个行和已命名的列 Series - 指单一列。DataFrame 中包含一个或多个 Series，每个 Series 均有一个名称 import pandas as pd # 创建 Series city_names = pd.Series(['San Francisco', 'San Jose', 'Sacramento']) population = pd.Series([852469, 1015785, 485199]) # 创建 DataFrame（若长度不一致，系统会用特殊的 NA/NAN 值填充缺失的值） pd.DataFrame({'City Name': city_names, 'Population': population}) # 从 csv 文件中创建 DataFrame california_housing_dataframe = pd.read_csv(\"https://storage.googleapis.com/mledu-datasets/california_housing_train.csv\", sep=\",\") california_housing_dataframe.describe() # 显示关于 DataFrame 的统计信息 california_housing_dataframe.head() # 前 5 个记录 california_housing_dataframe.hist('housing_median_age') # 绘制图标：了解值的分布 访问数据 # Pandas 自动创建一个从 0 开始的索引列 cities = pd.DataFrame({'City name': city_names, 'Population': population}) # 选择一列作为索引列（要求被索引列是数字列） # RangeIndex(start=0, stop=3, step=1) print(cities.index) for i in cities.index: print(i) # print(type(cities['City name'])) print(type(cities.loc[0])) # print(type(cities[['City name']])) print(type(cities.loc[[0]])) \"\"\" 0 San Francisco 1 San Jose 2 Sacramento Name: City name, dtype: object \"\"\" cities['City name'] cities['City name'][1] # San Jose # type(cities[0:2]) \"\"\" City name Population 0 San Francisco 852469 1 San Jose 1015785 \"\"\" print(cities[0:2]) # 第 0（这里的 0 表示索引值） 行 print(citie.loc[0]) # 第一行 print(cities.iloc[]) 操控数据 import numpy as np print(np.log(population)) \"\"\" 0 False 1 True 2 False dtype: bool \"\"\" population.apply(lambda val: val > 1000000) # Series.apply # 添加两个 Series cities['Area square miles'] = pd.Series([46.87, 176.53, 97.92]) cities['Population density'] = cities['Population'] / cities['Area square miles'] cities 参考 Pandas 简介 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/scipy/":{"url":"libs/3rdparty/scipy/","title":"scipy","keywords":"","body":"SciPy Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/seaborn/":{"url":"libs/3rdparty/seaborn/","title":"seaborn","keywords":"","body":"Seaborn Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/statsmodels/":{"url":"libs/3rdparty/statsmodels/","title":"statsmodels","keywords":"","body":"statsmodels Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"libs/3rdparty/requests/":{"url":"libs/3rdparty/requests/","title":"requests","keywords":"","body":"Requests 范例 class API() def __init__(self): self.timeout = 5 self.timeout_sleep = 60 def get(self): ret = '' req = { 'url': 'https://www.baidu.com', 'method': 'GET', 'body': '' } try: res = requests.get( url=req['url'], headers=req['headers'], data=req['body'], timeout=self.timeout) if res.status_code == 200: logging.info('[请求成功]') ret = res.text else: logging.info('[状态码({})异常] 系统将休息 5 分钟后重试......' .format(res.status_code)) time.sleep(300) except requests.exceptions.Timeout: logging.info('[请求超时]！系统将休息 1 分钟后重试.....') time.sleep(self.timeout_sleep) return ret Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"style/":{"url":"style/","title":"style","keywords":"","body":"Python 代码风格 参考 Google Python Style Guide Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"style/pythonic/":{"url":"style/pythonic/","title":"Pythonic","keywords":"","body":"Pythonic The Zen of Python $ python3 -c \"import this\" The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren't special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you're Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let's do more of those! str in in 除了可以判断元素是否在列表中以外，还可以判断字符串之间是否存在包含关系。 # Non-Pythonic def contain(x, y): import re return True if re.search(x, y) else False # Pythonic def contain(x, y): return x in y 直接赋值、浅拷贝和深拷贝 Name 示例 描述 赋值引用 b = a 即对象的引用；a 和 b 指向同一个对象 浅拷贝 b = a.copy() 只拷贝父对象不拷贝子对象；a 和 b 是两个相对独立的对象，他们的子对象指向同一对象 深拷贝 b = copy.deepcopy(a) 完全拷贝父对象及其子对象；a 和 b 是两个完全独立的对象 赋值引用 浅拷贝 深拷贝 获取列表、元组、字符串中的最后一个元素 a_list = [1, 2, 3, 4] a_tuple = (\"a\", 1, \"b\", 2) a_string = \"abc\" # Non-Pythonic a_list[len(a_list) - 1] # 4 a_tuple[len(a_tuple) - 1] # 2 a_string[len(a_string) - 1] # 'c' # Pythonic a_list[-1] # 4 a_tuple[-1] # 2 a_string[-1] # 'c' 交换两个变量的值（Swap） # Non-Pythonic temp = a a = b b = temp # Pythonic a, b = b, a Packing/Unpacking packing def func(*args): print(type(args), len(args)) func(1) # 1 func(1, 2) # 2 func(1, 2, 3) # 3 def func(**kwargs): for key in kwargs: print(\"key: %s, value: %s\" % (key, kwargs[key])) func(x=1, y=2) Unpacking def func(a, b, c, d): pass lst = [1, 2, 3, 4] # TypeError: fun() takes exactly 4 arguments (1 given) func(lst) # Unpacking list into four arguments func(*lst) def func(a=None, b=None, c=None, d=None) pass dic = {\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4} # TypeError: fun() takes exactly 4 arguments (1 given) func(dic) func(**dic) 列表推导式（List Comprehensions） new_list = [expression(i) for i in old_list if conditional(i)] # Non-Pythonic new_list = [] for x in range(1, 101): if x % 2 == 0: new_list.append(x) # Pythonic new_list = [x for x in range(1, 101) if x % 2 == 0] import random new_dict = {i: random.randint(0, 10) for i in range(10, -1, -1)} 三元符 # Non-Pythonic x = 0 if x != 0: b = True else: b = False print(b) # False # Pythonic x = 1 b = True if x != 0 else False print(b) # True 链式比较 # Non-Pythonic a = 10 b = 20 print(a >= 1 and a # Pythonic a, b = 10, 20 print(1 真值判断 a = 123 b = [\"rbd\", \"radosgw\", \"cephfs\"] c = {\"name\": \"John\", age: 18} # Non-Pythonic if a != 0 and len(b) != 0 and c != {}: print(\"All True\") # Pythonic if a and b and c: print(\"All True\") https://docs.python.org/release/2.5.2/lib/truth.html Create a length-N string/list/tuple of the same thing # Pythonic string = string * 10 lst = [None] * 10 tuple = (None) * 10 字符串索引/截取 string = \"Hello\" # Non-Pythonic string_arr = list(string) # ['H', 'e', 'l', 'l', 'o'] print(string_arr[0], string_arr[4]) # H o # Pythonic print(string[0], string[4]) # H o print(string[0:3]) # Hel 连接字符串列表 str_list = [\"a\", \"b\", \"c\"] # Non-Pythonic result = \"-\" for i, s in enumerate(str_list): if i != len(str_list) - 1: result = s + result # Pythonic result1 = \"-\".join(str_list) # a-b-c result2 = \" \".join(str_list) # a b c result3 = \"\".join(str_list) # abc 字符串反转 string = \"This is a tree.\" # Option 1: Non-Pythonic def reverse_str(s): \"\"\" string = \"\" s_len = len(s) for i in range(s_len): string += s[s_len - 1 - i] return string \"\"\" string = \"\" for i in range(len(s) - 1, -1, -1): string += s[i] return string # Option 2: Non-Pythonic def reverse_str(s): return \"\".join([s[i] for i in range(len(s) - 1, -1, -1)]) # Option 3: Non-Pythonic def reverse_str(s): string = \"\" for x in list(s): string = x + string return string # Pythonic def reverse_str(s): return s[::-1] 参考 让你的 Python 代码更加 pythonic Python Code Style Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"style/style-guide.html":{"url":"style/style-guide.html","title":"Python 规范","keywords":"","body":"Python 规范 命名规范 module_name, package_name, ClassName, method_name, ExceptionName, function_name, GLOBAL_CONSTANT_NAME, global_var_name, instance_var_name, function_parameter_name, local_var_name YAPF formatter 安装 # 用 Python3 安装的 yapf，仅限格式化 Python3 的代码 $ pip install yapf 命令行参数： -p/--parallel: 格式化多个文件时使用多线程 -d/--diff: 打印不同点 -i/--in-place: 直接对原文件进行修改 -r/--recursive: 对目录下的所有文件进行递归格式化 --style: 指定格式化样式 格式化样式 搜索顺序： 命令行（--style='{based_on_style: chromium, indent_width: 4}'） 当前目录或父目录之一的 .style.yapf 的 [style] 部分 当前目录或父目录之一的 setup.cfg 的 [yapf] 部分（导出配置：yapf --style-help > style.cfg） Home 目录的 ~/.config/yapf/style 文件 内置样式： pep8 google chromium 示例 example.py x = { 'a':37,'b':42, 'c':927} y = 'hello ''world' z = 'hello '+'world' a = 'hello {}'.format('world') class foo ( object ): def f (self ): return 37*-+2 def g(self, x,y=42): return y def f ( a ) : return 37+-+a[42-x : y**3] .style.yapf [style] based_on_style = google spaces_before_comment = 4 split_before_logical_operator = true 格式化 # 格式化并打印，但不修改文件 $ yapf example.py # 打印格式化前后区别 $ yapf --diff example.py # 格式化并修改文件 $ yapf -i example.py # 使用多线程对当前目录下的所有文件进行格式化并修改 $ yapf -p -i -r ./ # 通过命令行指定格式化样式 $ yapf --style='{based_on_style: chromium, indent_width: 4}' -p -i -r ./ 参考 Google Python Style Guide github.com/google/yapf Python 命名规范 Python 格式化工具 yapf 使用说明 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/":{"url":"toolbox/","title":"toolbox","keywords":"","body":"Python 工具箱 打包（packaging） wheel egg 安装包 pip setuptools easy_install 发布包 pypi Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/environment/":{"url":"toolbox/environment/","title":"environment","keywords":"","body":"Python 环境管理 pyenv - Python 版本管理 virtualenv - 项目环境隔离（解决依赖包隔离） conda env - 运行时环境中软件包的版本管理和隔离（在 Conda 中，Python 也是一个软件包）；相当于在 pyenv 的基础上增加了对 Python 包的版本管理和环境隔离 pipenv - Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/packaging/egg.html":{"url":"toolbox/packaging/egg.html","title":"Egg","keywords":"","body":"Egg Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pyinstaller.html":{"url":"toolbox/pyinstaller.html","title":"PyInstaller","keywords":"","body":"PyInstaller PyInstaller 可以将 Python 程序及其依赖打包成一个可执行文件，用户运行程序时不需要安装 Python 解释器或模块。PyInstaller 可以在 Windows、Mac OS X 和 Linux 上运行，但不能跨平台运行：为了制作 Windows App 必须在 Windows 上运行 PyInstaller；为了制作 Linux App 必须在 Linux 上运行 PyInstaller。 参数 参数 含义 -F -onefile 指定打包后只生成一个exe格式的文件 -D -onedir 创建一个目录，包含exe文件，但会依赖很多文件（默认选项） -c –console, –nowindowed 使用控制台，无界面(默认) -w –windowed, –noconsole 使用窗口，无控制台 -p 添加搜索路径，让其找到对应的库。 -i 改变生成程序的icon图标 Windows Windows XP 以上（含） 依赖模块 PyWin32/pypiwin32 二选一；pip/easy_instsall 安装 PyInstaller 会自动安装 pypiwin32 pefile 必需 pip-Win 推荐，非必需 Mac OS X Mac OS X 10.7 以上（含） Linux 安装 % pip install -U pyinstaller 示例 # 如果使用 anaconda，需要指定动态链接库 $ echo 'export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:~/anaconda3/lib' >> ~/.bashrc $ source ~/.bashrc # 打包 $ pyinstaller -F wx_detection.py $ trre . ├── build │ └── wx_detection │ ├── Analysis-00.toc │ ├── base_library.zip │ ├── EXE-00.toc │ ├── PKG-00.pkg │ ├── PKG-00.toc │ ├── PYZ-00.pyz │ ├── PYZ-00.toc │ ├── warn-wx_detection.txt │ └── xref-wx_detection.html ├── dist │ └── wx_detection ├── __pycache__ │ └── wx_detection.cpython-36.pyc ├── wx_detection.py └── wx_detection.spec Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pypa/pip.html":{"url":"toolbox/pypa/pip.html","title":"Pip - 安装 Python 包的工具","keywords":"","body":"Pip - 安装 Python 包的工具 Pip 与 Python 的关系 简单概括：不同版本的 Python 需要安装对应版本的 Pip，比如：python2.7 需要安装 pip2.7，python3.5 需要安装 pip3.5。也就是说，Pip 是由 Python 来管理的，而不是由 Pip 来管理 Python；Pip 无法管理 Python 的多版本环境问题，仅用于安装 Python 依赖包。 安装 CentOS $ yum install -y python-pip # 更新 $ pip install --upgrade pip Ubuntu $ apt-get install python-pip # 更新 $ pip install --upgrade pip 命令 # 查看已安装的软件包 $ pip freeze 项目依赖 pip freeze # 导出依赖 $ pip freeze > requirements.txt # 安装依赖 $ pip install -r requirements.txt pipreqs pip freeze 保存的是当前环境中使用 pip install 安装的所有软件包及依赖，这会包含一些当前项目没有使用到的软件包。而 pipreqs 是根据项目代码的导入情况来生成依赖文件。 $ pip install pipreqs $ pipreqs /home/project/location Successfully saved requirements file in /home/project/location/requirements.txt 参考 Document - pip Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pypa/pipenv.html":{"url":"toolbox/pypa/pipenv.html","title":"Pipenv","keywords":"","body":"Pipenv Pipenv 是 python.org 官方推荐的 Python 打包工具，它会自动为你的项目创建和管理一个虚拟环境，并在安装/卸载软件包时从你的 Pipfile 中添加/删除软件包。 特点 安装 ubuntu 17.10 # 不支持 ubuntu 14.04 $ apt-get install software-properties-common python-software-properties $ add-apt-repository ppa:pypa/ppa $ apt-get update $ apt-get install pipenv pip # $ pip --version pip 9.0.1 from /usr/local/lib/python2.7/dist-packages (python 2.7) $ pip install pipenv $ pipenv --version pipenv, version 11.1.3 Pipfile Pipfile是社区拟定的依赖管理文件，用于替代过于简陋的 pip 的 requirements.txt 文件。 用法 # 激活并进入虚拟环境（使用 exit 退出） $ pipenv shell # 显示虚拟环境 $ pipenv --venv /home/yin/.local/share/virtualenvs/pipenvtest-dZqycsbZ # 显示 Python 解释器路径 $ pipenv --py /home/yin/.local/share/virtualenvs/pipenvtest-dZqycsbZ/bin/python # 更新 Pipfile.lock $ pipenv lock $ pipenv --two pipenv instal requests cat Pipfile pipenv lock cat Pipfile.lock pipenv lock -r pipenv shell pip freeze exit 参考 Python 新利器之 pipenv 使用 pipenv 管理你的项目 Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pypa/pypi.html":{"url":"toolbox/pypa/pypi.html","title":"PyPI · 发布 Python 包","keywords":"","body":"PyPI · 发布 Python 包 PyPI（Python Package Index）是 Python 的软件存储库。 项目目录 一个项目理论上可以包含多个软件包（子包），而最终发布的是整个项目，也就是我们常说的 Python包（可能包含多个子包）。 项目名称可以任意命名，软件包名甚至也可以与著名软件包（如 numpy）同名，但是安装这样的 Python包 后会导致其中的软件包覆盖本地同名的软件包。所以，建议一个项目只包含一个软件包，且项目名称与软件包名相同。 测试方案 pynamespace # 项目名称 ├── subpkg_a # 软件包名 │ └── __init__.py ├── subpkg_b # 软件包名 │ └── __init__.py ├── LICENSE ├── README.md └── setup.cfg └── setup.py 推荐方案 pythonx # 项目名称 ├── pythonx # 软件包名 │ └── __init__.py ├── LICENSE ├── README.md └── setup.cfg └── setup.py 项目文件 setup.py import setuptools with open(\"README.md\", \"r\") as fh: long_description = fh.read() setuptools.setup( name=\"pythonx\", version=\"0.0.1\", author=\"Jins Yin\", author_email=\"jinsyin@gmail.com\", description=\"Python X\", long_description=long_description, long_description_content_type=\"text/markdown\", url=\"https://github.com/jinsyin/x/tree/master/pythonx\", packages=setuptools.find_packages(), classifiers=[ \"Programming Language :: Python :: 3\", \"License :: OSI Approved :: MIT License\", \"Operating System :: OS Independent\", ], ) setup() 参数描述： name - 项目名称，即 Python包 的名称，必须在 PyPI 上是唯一的，可通过 pip search 来预检 version - long_description - 项目详细描述 license - 项目详细描述 setup.cfg [metadata] license_files = LICENSE [bdist_wheel] universal = 1 README.md # PythonX LICENSE 前往 choosealicense.com 选择一个 license ，将内容复制粘贴到该文件。 打包项目 支持两种打包方式（两者共存是，pip 优先选择 wheel）： sdist（Source Distributions）- 即源码包 wheel - 采用预编译格式，安装速度更快 # 安装最新版本的 setuptools 和 wheel $ python3 -m pip install --user --upgrade setuptools $ python3 setup.py sdist bdist_wheel ├── build │ ├── bdist.linux-x86_64 │ └── lib │ └── pythonx │ └── __init__.py ├── dist │ ├── pythonx-0.0.1-py2.py3-none-any.whl │ └── pythonx-0.0.1.tar.gz ├── LICENSE ├── pythonx │ └── __init__.py ├── pythonx.egg-info │ ├── dependency_links.txt │ ├── PKG-INFO │ ├── SOURCES.txt │ └── top_level.txt ├── README.md ├── setup.cfg └── setup.py 注册账号 测试账号 前往 PyPI 测试版注册页面 注册账号 验证注册邮箱 正式账号 前往 PyPI 注册页面 注册账号 验证注册邮箱 本机配置 PyPI 访问地址和账号 $ vi ~/.pypirc [distutils] index-servers = pypi [pypi] username: password:# 可选 上传项目 $ python3 -m twine upload --repository-url https://test.pypi.org/legacy/ dist/* python3 -m twine upload dist/* 使用 安装 $ pip install pythonx 测试 $ python >>> import x, y >>> x.name X >>> y.name Y 更新 更新项目后需要修改版本（version）才能上传，上传完成后使用 pip install --upgrade pythonx 更新本地库。 参考 Python Packaging User Guide Packaging Python Projects A sample Python project Requests: HTTP for Humans™ Packaging namespace packages Packaging History Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pypa/setuptools.html":{"url":"toolbox/pypa/setuptools.html","title":"setuptools","keywords":"","body":"setuptools Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pypa/twine.html":{"url":"toolbox/pypa/twine.html","title":"twine","keywords":"","body":"twine Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pypa/virtualenv.html":{"url":"toolbox/pypa/virtualenv.html","title":"Virtualenv","keywords":"","body":"Virtualenv Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/pypa/wheel.html":{"url":"toolbox/pypa/wheel.html","title":"Wheel","keywords":"","body":"Wheel 根据 application 包含的代码类型以及其所支持的 python 版本， wheel 格式可细分为三种 Universal wheel: 纯 python 代码，并且支持 python 2 和 3 Pure python wheel: 纯 python 代码，不同时支持 python2 和 3 Platform wheel: 非纯 python 代码 参考 Wheel vs Egg Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/python-building.html":{"url":"toolbox/python-building.html","title":"Python 构建打包","keywords":"","body":"Python 构建打包 setuptools % python setup.py install buildout https://www.zhihu.com/question/21639330 wheels pyintaller 可以自动搜索依赖，并将文件打包成单独的exe Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"toolbox/setuptools.html":{"url":"toolbox/setuptools.html","title":"setuptools 工具","keywords":"","body":"setuptools 工具 % apt-get install python-setuptools setuptools setup.cfg setup.py from setuptools import setup setup( ) Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "},"tutorials.html":{"url":"tutorials.html","title":"教程","keywords":"","body":"Python 教程 教程 Google's Python Class Learn Python Copyright © 2019-2020 | CC BY-NC-SA 4.0 相关网站: 知识库 微架构师 快速入门            更新于 2020-03-14 "}}